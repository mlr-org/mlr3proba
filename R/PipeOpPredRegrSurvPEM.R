#' @title PipeOpPredRegrSurvPEM
#' @name mlr_pipeops_trafopred_regrsurv_PEM
#'
#' @description
#' Transform [PredictionRegr] to [PredictionSurv].
#'
#' @section Dictionary:
#' This [PipeOp][mlr3pipelines::PipeOp] can be instantiated via the
#' [dictionary][mlr3misc::Dictionary] [mlr3pipelines::mlr_pipeops]
#' or with the associated sugar function [mlr3pipelines::po()]:
#' ```
#' PipeOpPredRegrSurvPEM$new()
#' mlr_pipeops$get("trafopred_regrsurv_PEM")
#' po("trafopred_regrsurv_PEM")
#' ```
#'
#' @section Input and Output Channels:
#' The input is a [PredictionRegr] and a [data.table][data.table::data.table]
#' with the transformed data both generated by [PipeOpTaskSurvRegrPEM].
#' The output is the input [PredictionRegr] transformed to a [PredictionSurv].
#' Only works during prediction phase.
#'
#' @family PipeOps
#' @family Transformation PipeOps
#' @export
PipeOpPredRegrSurvPEM = R6Class(
  "PipeOpPredRegrSurvPEM",
  inherit = mlr3pipelines::PipeOp,

  public = list(
    #' @description
    #' Creates a new instance of this [R6][R6::R6Class] class.
    #' @param id (character(1))\cr
    #' Identifier of the resulting object.
    initialize = function(id = "trafopred_regrsurv_PEM") {
      super$initialize(
        id = id,
        input = data.table(
          name = c("input", "transformed_data"),
          train = c("NULL", "data.table"),
          predict = c("PredictionRegr", "data.table")
        ),
        output = data.table(
          name = "output",
          train = "NULL",
          predict = "PredictionSurv"
        )
      )
    }
  ),

  private = list(
    .predict = function(input) {
      pred = input[[1]]
      data = input[[2]]
      assert_true(!is.null(pred$response))
      # probability of having the event (1) in each respective interval
      # is the discrete-time hazard
      data = cbind(data, dt_hazard = pred$response)

      # From theory, convert hazards to surv as exp(-cumsum(h(t) * exp(offset)))
      rows_per_id = nrow(data) / length(unique(data$id))
      
      # If 'single_event', 'cr', 'msm')
      surv = t(vapply(unique(data$id), function(unique_id) {
        exp(-cumsum(data[data$id == unique_id, ][["dt_hazard"]] * exp(data[data$id == unique_id, ][["offset"]])))
      }, numeric(rows_per_id)))

      unique_end_times = sort(unique(data$tend))
      # coerce to distribution and crank
      pred_list = .surv_return(times = unique_end_times, surv = surv)

      # select the real tend values by only selecting the last row of each id
      # basically a slightly more complex unique()
      real_tend = data$obs_times[seq_len(nrow(data)) %% rows_per_id == 0]

      ids = unique(data$id)
      # select last row for every id => observed times
      id = PEM_status = NULL # to fix note
      data = data[, .SD[.N, list(PEM_status)], by = id]

      # create prediction object
      p = PredictionSurv$new(
        row_ids = ids,
        crank = pred_list$crank, distr = pred_list$distr,
        truth = Surv(real_tend, as.integer(as.character(data$PEM_status))))

      list(p)
    },

    .train = function(input) {
      self$state = list()
      list(input)
    }
  )
)
register_pipeop("trafopred_regrsurv_PEM", PipeOpPredRegrSurvPEM)
